### 第7章 字典和散列表

* 集合、字典和散列表可以存储不重复的值。
* 在集合中，我们感兴趣的是每个值本身，并把它当作主要元素。
* 在字典中，我们用[键，值]的形式来存储数据。在散列表中也是一样（也是以[键，值]对的形式来存储数据）。

#### 字典

* 在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。
* 字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。
* 字典也称作映射。

#### 散列表

* 散列算法的作用是尽可能快地在数据结构中找到一个值。
* 散列函数的作用是给定一个键值，然后返回值在表中的地址。
* 我们将要使用最常见的散列函数——“lose lose”散列函数，方法是简单地将每个键值中的每个字母的ASCII值相加。

#### 处理散列表中的冲突

* 有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突。
* 处理冲突有几种方法：分离链接、线性探查和双散列法。
    1. 分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。
    2. 另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推。

#### 创建更好的散列函数

* 一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。
* 一个可以实现的比“lose lose”更好的散列函数是djb2。这并不是最好的散列函数，但这是最被社区推荐的散列函数之一。
    ```javascript
      var djb2HashCode = function (key) {
        var hash = 5381; 
        for (var i = 0; i < key.length; i++) { 
        hash = hash * 33 + key.charCodeAt(i); 
        }
        return hash % 1013; 
    };
    ```